# 面向数据挖掘
一个小示例
一共有1000人
假定商品A和B有关联
80人同时购买了商品A和商品B
购买了一个商品之后又购买了另一种商品的可能性：        
80/100=80%

变换，隐藏是我们保护的方法
# 隐私保护
- k-anonymity: 保证每个数据项在数据集中至少有k个相同的数据项。k-anonymity保证了单独个体被准确标识的概率最大为1/k，但却无法保证隐私不被泄露
- l-diversity: 保证每个数据项的敏感属性至少有l个不同的值。l-diversity保证攻击者最多只能以 1/l 的概率确认某个用户的敏感信息，但无法保证隐私不被泄露
- t-closeness: 保证每个数据项的敏感属性的分布与整个数据集的分布相差不大
猜中的概率分别为1/k, 1/l, 1/t

# 数据匿名化方法

匿名化方法	思想
泛化	用更抽象、概括的值或区间代替精确值
抑制	将数据表中的数据直接删除或隐藏
聚类	按照给定的规则将数据集分成各类簇，尽量保证簇内对象相似，不同簇的对象相异
微聚集	相似的数据划分在同一个类中，每个类至少有k条记录，用类质心代替类中所有记录的准标识符属性值
分解	根据敏感属性值对数据表分组，尽量使得同一组的敏感属性值不同，将分组后的数据表拆分为分别包含准标识符属性信息和包含敏感属性信息的两张表
置换	对数据表分组，把每组内的敏感属性值随机交换，打乱顺序，再拆分数据表，对外发布

泛化:准确标识符属性有数值型和分类型
好处:泛化后的数据更加抽象，隐私泄露的风险降低
坏处:泛化后的数据丢失了原始数据的精确信息，数据的价值降低
比如我们有数据值泛化树

域泛化:将数据的取值范围扩大，如年龄段、收入段

值泛化

差分攻击:通过对比两个数据集的差异，推断出某个特定的数据项
对数据集Ｄ的各种映射函数被定义为查询（Query），用F={f1,f2,⋯}来表示一组查询，算法Ｍ对查询Ｆ的结果进行处理，使之满足隐私保护的条件，此过程称为隐私保护机制
设数据集Ｄ 和Ｄ′具有相同的属性结构，两者的对称差记作D∆D′，|D∆D′|表示D∆D′中记录的数量，若|D∆D′|=1，则称D和D′为邻近数据集 （Adjacent Dataset）
局部敏感度：设有函数f:D→R_d，输入为数据集，输出为d维实数向量。对于给定的数据集D 和它的任意邻近数据集D′,
$$LS_f=max┬D^′‖f(D)−f(D′)‖_1$$
称为函数f在D上的局部敏感度

数值型差分隐私：拉普拉斯和高斯机制
拉普拉斯分布是一种连续的概率分布，其概率密度函数为：
$$f(x|μ,b┤)=1/2bexp{−|x−μ|/b}$$
其中位置参数为μ，尺度参数为b(b>0)，该分布的期望值为μ，方差为$2b^2$

记位置参数μ为0，尺度参数为b的拉普拉斯分布为Lap(b)，它的概率密度函数为：
$$p(x)=\frac{b}{2}exp{\frac{−|x|}b}$$

$$M(D)=f(D)+Lap(Δf/ε)$$
其实理解一下的话，首先我们是全局敏感度不能超过Δf，然后我们加上拉普拉斯噪声，这样就可以保证差分隐私了，而且我们的ε越大，噪声就越小，隐私就越好，但是精度就越差

指数机制:
设随机算法M输入为数据集D，输出为一实体对象 $r∈Range，q(D,r)$为可用性函数，Δq为函数q(D,r)的敏感度，若算法M以正比于exp{εq(D,r)/2Δq}的概率从Range中选择并输出r，那么算法M提供ε−差分隐私保护

# 同态加密
同态加密是指对加密数据进行运算后，再解密得到的结果与对原始数据进行运算后的结果相同，比如医院没有计算能力，但是数据平台有计算能力但是没有数据
同态加密有四种算法

1.KeyGen(λ)：密钥生成算法，输入为安全参数λ，输出为公钥pk和私钥sk
2.Enc(pk,m)：加密算法，输入为公钥pk和明文m，输出为密文c
3.Dec(sk,c)：解密算法，输入为私钥sk和密文c，输出为明文m
4.Eval(pk,f,c1,c2)：计算算法，输入为公钥pk、函数f和密文c1、c2，输出为密文c3，满足$Dec(sk,c3)=f(Dec(sk,c1),Dec(sk,c2))$

半同态加密:
如果加密和解密运算满足:
$$Dec(Enc(a)⊗Enc(b))=a⊕b$$

直到2009年，当时在斯坦福大学计算机科学系就读的博士生Craig Gentry才构造出了第一个真正的全同态加密体制
随后很多密码学家在全同态加密体制的研究方面取得进展，使得全同态加密继续向实用化靠近，但因当前算法复杂度问题，离实用仍有距离

#乘法同台加密有常见的几种

1. ElGamal加密体制
首先定义离散对数问题给定素数p，Z_p^∗的一个生成元α，以及元素β∈Z_p^∗ ，计算整数x，其中0 < x≤ p−2 满足β≡α^x(mod p)成立

记群G上某ElGamal加密系统的公钥为pk=(G,q,g,ℎ) ，其中ℎ=g^x，x为秘密私钥，对消息m实施ElGamal加密后的密文可表示为E(m)=(g^r,m⋅ℎ^r)，其中r←_RZ_q，对于任意的明文消息m_1和m_2，ElGamal加密系统满足如下乘法同态性质：
$E(m_1)⋅E(m_2)=(g^r_1,m_1⋅ℎ^r_1)(g^r_2,m_2⋅ℎ^r_2)=(g^r_1+r_2,(m_1⋅m_2)ℎ^r_1+r_2)=E(m_1⋅m_2)
$同理，ElGamal体制也支持任意次的乘法同态操作

2. Paillier加密体制
这个基于判定合数剩余问题
令N=pq，其中，p和q为安全素数，任给定z∈Z_N^2^∗ ，判定z为N次剩余还是非N次剩余
N次剩余定义：给定N=pq ，其中， p和q为安全素数，给定z∈Z_N^2^∗ ，若存在某个y∈Z_N^2^∗ ，使得z=y^N(modN^2) 成立，则称z为（模N^2的） N次剩余；否则，则称z为（模N^2的）非 N次剩余
记Paillier加密系统的公钥为pk=(N,g)，其中N为公开模，而g为公开基，对消息实m施Paillier加密后的密文可表示为E(m)=g^mr^NmodN^2，对于任意的明文消息m_1和m_2 ，Paillier加密系统满足如下加法同态性质：


# 多方安全计算
是不是可以对数据脱敏后授权？但这样会降低数据的可用性。或者可以将数据发给可信第三方，由可信第三方处理数据，但是真正可信的第三方很难找到；再或者通过签订合约，将数据发送给其中一方进行处理，事实上，这样也不能完全保证数据不被泄露。安全多方计算就是为了解决这类问题而提出的，它能够实现互不信任的参与方之间保护隐私的协同计算

第一个问题:百万富翁问题
假设Alice和Bob是两个百万富翁，他们想要比较谁的财富更多，但是又不想透露自己的财富，这时候安全多方计算就可以派上用场了

---
百万富翁协议
输入：Alice和Bob的财富值 i，j ，Alice拥有公私钥
输出： i≥j 或 i< j

定义. 设Alice拥有的财富为i,Bob拥有的财富为j，单位均为百万，其中1≤i,j ≤10
令M为N 个bit表示的非负整数的集合，Q_N是从M映射到M的所有一一映射的集合
E_a是Alice的公钥，通过从Q_N中随机选择一个元素生成，D_a为私钥
1. Bob选择一个N bit的随机整数x，并私下计算k=E_a(x)
2. Bob将k−j发送给Alice
3. Alice计算Y_u= D_a(k−j+ u)的值，其中u=1,2,⋯,10
注意，我们这里是简化版，i和j都是1-10里面的数字，所以我们这里面现在的u是遍历了，那么Bob知道第j个数字是随机数x，但是不知道其他解密数值
4. Alice生成一个N/2 bit的随机素数p，并对所有u计算Z_u = Y_u(mod p)，该随机素数需保证Z_u中所有数至少相差2
5. Alice对序列Z_u进行处理，将p和序列z_1,z_2,⋯,z_i,z_i+1+1,⋯,z_10+1发送给Bob

如果省略步骤4：Alice直接对Y_u进行处理，从第i+1个位置开始对数值进行加一处理并发送给Bob，由于Bob可以使用公钥E_a对处理后的序列重新加密，因此只要观察重新加密后的序列就可以发现序列从第几个数开始就被更改了，所以步骤4不可省略；

