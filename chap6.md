！ 这一章节有点难
# slammer蠕虫
- 为何操作系统安全漏洞广泛存在
 - 其一，现代操作系统是规模庞大的软件系统
 - 其二，现代操作系统的设计以性能为最主要目标，而非安全性

# 进程角度的内存管理

linux内核为每一个进程空间维护独立的线程
用户区内存空间包含了6个重要区域：

文本段：进程的可执行二进制源代码
数据段：初始化了的静态变量和全局变量
BSS段 ：未初始化的静态变量和全局变量
堆区   ：由程序申请释放
内存映射段：映射共享内存和动态链接库
栈区   ：包含了函数调用信息和局部变量

| 区域名称     | 存储内容                            | 权限  | 增长方向 | 分配时间        |
| ------------ | ----------------------------------- | ----- | -------- | --------------- |
| 文本段       | 二进制可执行机器码                  | 只读  | 固定     | 进程初始化      |
| 数据段       | 初始化了的静态、全局变量            | 读写  | 固定     | 进程初始化      |
| BSS段        | 未初始化的静态、全局变量            | 读写  | 固定     | 进程初始化      |
| 堆区         | 由进程执行的逻辑决定                | 读写  | 向高地址 | 堆管理器申请内核分配 |
| 内存映射段   | 动态链接库、共享内存的映射信息      | 内容相关 | 向低地址 | 运行时内核分配   |
| 栈区         | 函数调用信息与局部变量              | 读写  | 向低地址 | 函数调用时分配  |
![image](/image/memory.png)
栈区内存的根本作用:
保存主调函数（Caller）的状态信息
以在调用结束后恢复主调函数状态
并创建被调函数(Callee)的状态信息

# 函数调用历程
我们首先考虑一个简单的C++函数的汇编语言
我们关注四个寄存器:
ESP(Stack Pointer)
EBP(Base Pointer)
EAX(Accumulator X)
EIP(Instruction Pointer)
```cpp
int add(int a, int b) {
    return a + b;
}
int main() {
    int a = 1;
    int b = 2;
    int c = add(a, b);
    return 0;
}
```
我们可以看到这个函数的汇编代码
```asm
add(int, int):
    push    ebp
    mov     ebp, esp
    mov     eax, [ebp+8]
    add     eax, [ebp+12]
    pop     ebp
    ret
main():
    push    ebp
    mov     ebp, esp
    sub     esp, 8
    mov     dword ptr [ebp-4], 1
    mov     dword ptr [ebp-8], 2
    mov     eax, [ebp-4]
    push    eax
    mov     eax, [ebp-8]
    push    eax
    call    add(int, int)
    add     esp, 8
    mov     dword ptr [ebp-12], eax
    mov     eax, 0
    leave
    ret
```
注意这里push进去的是系统的堆栈，我们运行main函数的时候，我们的堆栈是这样的
首先ebp指向的是栈底，esp指向的是栈顶,ebp被push进去，然后esp指向的是ebp，这个时候esp等于ebp，也就是栈底等于栈顶，所以我们判断栈为空的代码是ebp==esp然后esp向下8个，将两个参数push进去，然后调用add函数，add函数的参数是在ebp+8和ebp+12的位置，然后我们将ebp-12的位置赋值为eax，然后leave，ret，ret的是返回地址，leave是将ebp赋值给esp，然后pop ebp，这样就完成了函数的调用，在此期间，我们的eip是这样子变化的首先main函数的eip是main函数的地址，然后call add函数的时候，eip是add函数的地址，然后ret的时候，eip是main函数的地址，这样就完成了函数的调用,另外我们看一下再call add函数之后，我们需要销毁栈，所以我们需要add esp, 8，这样就完成了函数的调用，在代码里面没有体现eip是怎么变化的，实际上eip是在call的时候被压入栈中的，然后ret的时候被pop出来的，这样就完成了函数的调用
我们主要就是想办法将EIP寄存器指向恶意代码

#堆区的攻击方案
堆可以提供动态的内存，允许申请指定空间的大小的内存，我们堆的最小单元是Chunk
prev_size：当上一个Chunk为空闲，存储上一个Chunk大小，否则存上一个Chunk的数据
size：该Chunk大小
NON_MAIN_ARENA：是否属于子线程
IS_MMAPED：是否由mmap分配
PREV_INUSE：前一个Chunk是否被分配
bk, fd：链接Bin当中空闲块的前后向链表指针，只有在空闲时使用

堆溢出攻击:
- 1.堆块A是可以发生溢出的堆块，B和C是被分配的状态的堆块，C是我们攻击目标块，攻击者首先通过堆区溢出数据去改写Chunk B的size域，把Chunk C包含到Chunk B当中，以此构造了堆块重叠而后攻击者操纵控制逻辑，使被修改了size字段的Chunk B将被重新分配最终构造堆块重叠，攻击者可以通过读/写被重新分配的Chunk B来读/写块Chunk C当中的数据
- 2.利用堆管理的其他机制
堆喷（Heap Spray）并非是一种内存攻击的辅助技术；堆喷申请大量的堆区空间，并将其中填入大量的滑板指令（NOP）和攻击恶意代码；



栈溢出的本质是对栈帧返回地址的修改

# 高级的控制流劫持的方案

- 进程执行的更多细节
系统调用是内核空间与用户空间的桥梁
- 面向返回地址编程
基于栈区溢出攻击指令，将返回地址设置为戴拿段中的合法指令，组合现存的修改指令寄存器，构造的恶意指令片段称为Gadget，均以RET指令结尾，当一个执行之后，RET指令将跳转执行下一个，组合排列Badget,构造恶意寄存器系统调用
面向返回地址编程ROP可以绕过NX防御机制，因为虚假的返回地址被设置在代码段Text,也可以绕过ASRL因为其随机性不是很强，ROP可以绕过NX，ASRL防御机制，但是对于Stack Canary，ROP是无法绕过的,但是使用面向跳转编程的方式，我们可以绕过Stack Canary的防御机制
- 全局辅助表劫持
为了使进程可以找到动态链接库，我们需要使用全局偏移表
- 虚假vtable劫持
两种实现方法
- 1.直接改写vtable指向的函数指针，可以通过堆块覆盖完成
覆盖